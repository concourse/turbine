// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/garden/warden"
	"github.com/concourse/turbine/api/builds"
	"github.com/concourse/turbine/builder"
	"github.com/concourse/turbine/event"
)

type FakeBuilder struct {
	StartStub        func(builds.Build, event.Emitter, <-chan struct{}) (builder.RunningBuild, error)
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 builds.Build
		arg2 event.Emitter
		arg3 <-chan struct{}
	}
	startReturns struct {
		result1 builder.RunningBuild
		result2 error
	}
	AttachStub        func(builder.RunningBuild, event.Emitter, <-chan struct{}) (builder.ExitedBuild, error)
	attachMutex       sync.RWMutex
	attachArgsForCall []struct {
		arg1 builder.RunningBuild
		arg2 event.Emitter
		arg3 <-chan struct{}
	}
	attachReturns struct {
		result1 builder.ExitedBuild
		result2 error
	}
	HijackStub        func(builder.RunningBuild, warden.ProcessSpec, warden.ProcessIO) (warden.Process, error)
	hijackMutex       sync.RWMutex
	hijackArgsForCall []struct {
		arg1 builder.RunningBuild
		arg2 warden.ProcessSpec
		arg3 warden.ProcessIO
	}
	hijackReturns struct {
		result1 warden.Process
		result2 error
	}
	FinishStub        func(builder.ExitedBuild, event.Emitter, <-chan struct{}) (builds.Build, error)
	finishMutex       sync.RWMutex
	finishArgsForCall []struct {
		arg1 builder.ExitedBuild
		arg2 event.Emitter
		arg3 <-chan struct{}
	}
	finishReturns struct {
		result1 builds.Build
		result2 error
	}
}

func (fake *FakeBuilder) Start(arg1 builds.Build, arg2 event.Emitter, arg3 <-chan struct{}) (builder.RunningBuild, error) {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 builds.Build
		arg2 event.Emitter
		arg3 <-chan struct{}
	}{arg1, arg2, arg3})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub(arg1, arg2, arg3)
	} else {
		return fake.startReturns.result1, fake.startReturns.result2
	}
}

func (fake *FakeBuilder) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeBuilder) StartArgsForCall(i int) (builds.Build, event.Emitter, <-chan struct{}) {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return fake.startArgsForCall[i].arg1, fake.startArgsForCall[i].arg2, fake.startArgsForCall[i].arg3
}

func (fake *FakeBuilder) StartReturns(result1 builder.RunningBuild, result2 error) {
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 builder.RunningBuild
		result2 error
	}{result1, result2}
}

func (fake *FakeBuilder) Attach(arg1 builder.RunningBuild, arg2 event.Emitter, arg3 <-chan struct{}) (builder.ExitedBuild, error) {
	fake.attachMutex.Lock()
	fake.attachArgsForCall = append(fake.attachArgsForCall, struct {
		arg1 builder.RunningBuild
		arg2 event.Emitter
		arg3 <-chan struct{}
	}{arg1, arg2, arg3})
	fake.attachMutex.Unlock()
	if fake.AttachStub != nil {
		return fake.AttachStub(arg1, arg2, arg3)
	} else {
		return fake.attachReturns.result1, fake.attachReturns.result2
	}
}

func (fake *FakeBuilder) AttachCallCount() int {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return len(fake.attachArgsForCall)
}

func (fake *FakeBuilder) AttachArgsForCall(i int) (builder.RunningBuild, event.Emitter, <-chan struct{}) {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return fake.attachArgsForCall[i].arg1, fake.attachArgsForCall[i].arg2, fake.attachArgsForCall[i].arg3
}

func (fake *FakeBuilder) AttachReturns(result1 builder.ExitedBuild, result2 error) {
	fake.AttachStub = nil
	fake.attachReturns = struct {
		result1 builder.ExitedBuild
		result2 error
	}{result1, result2}
}

func (fake *FakeBuilder) Hijack(arg1 builder.RunningBuild, arg2 warden.ProcessSpec, arg3 warden.ProcessIO) (warden.Process, error) {
	fake.hijackMutex.Lock()
	fake.hijackArgsForCall = append(fake.hijackArgsForCall, struct {
		arg1 builder.RunningBuild
		arg2 warden.ProcessSpec
		arg3 warden.ProcessIO
	}{arg1, arg2, arg3})
	fake.hijackMutex.Unlock()
	if fake.HijackStub != nil {
		return fake.HijackStub(arg1, arg2, arg3)
	} else {
		return fake.hijackReturns.result1, fake.hijackReturns.result2
	}
}

func (fake *FakeBuilder) HijackCallCount() int {
	fake.hijackMutex.RLock()
	defer fake.hijackMutex.RUnlock()
	return len(fake.hijackArgsForCall)
}

func (fake *FakeBuilder) HijackArgsForCall(i int) (builder.RunningBuild, warden.ProcessSpec, warden.ProcessIO) {
	fake.hijackMutex.RLock()
	defer fake.hijackMutex.RUnlock()
	return fake.hijackArgsForCall[i].arg1, fake.hijackArgsForCall[i].arg2, fake.hijackArgsForCall[i].arg3
}

func (fake *FakeBuilder) HijackReturns(result1 warden.Process, result2 error) {
	fake.HijackStub = nil
	fake.hijackReturns = struct {
		result1 warden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeBuilder) Finish(arg1 builder.ExitedBuild, arg2 event.Emitter, arg3 <-chan struct{}) (builds.Build, error) {
	fake.finishMutex.Lock()
	fake.finishArgsForCall = append(fake.finishArgsForCall, struct {
		arg1 builder.ExitedBuild
		arg2 event.Emitter
		arg3 <-chan struct{}
	}{arg1, arg2, arg3})
	fake.finishMutex.Unlock()
	if fake.FinishStub != nil {
		return fake.FinishStub(arg1, arg2, arg3)
	} else {
		return fake.finishReturns.result1, fake.finishReturns.result2
	}
}

func (fake *FakeBuilder) FinishCallCount() int {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return len(fake.finishArgsForCall)
}

func (fake *FakeBuilder) FinishArgsForCall(i int) (builder.ExitedBuild, event.Emitter, <-chan struct{}) {
	fake.finishMutex.RLock()
	defer fake.finishMutex.RUnlock()
	return fake.finishArgsForCall[i].arg1, fake.finishArgsForCall[i].arg2, fake.finishArgsForCall[i].arg3
}

func (fake *FakeBuilder) FinishReturns(result1 builds.Build, result2 error) {
	fake.FinishStub = nil
	fake.finishReturns = struct {
		result1 builds.Build
		result2 error
	}{result1, result2}
}

var _ builder.Builder = new(FakeBuilder)
