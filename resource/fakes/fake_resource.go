// This file was generated by counterfeiter
package fakes

import (
	"io"
	"sync"

	"github.com/concourse/turbine"
	"github.com/concourse/turbine/resource"
)

type FakeResource struct {
	InStub        func(turbine.Input) (io.Reader, turbine.Input, turbine.Config, error)
	inMutex       sync.RWMutex
	inArgsForCall []struct {
		arg1 turbine.Input
	}
	inReturns struct {
		result1 io.Reader
		result2 turbine.Input
		result3 turbine.Config
		result4 error
	}
	OutStub        func(io.Reader, turbine.Output) (turbine.Output, error)
	outMutex       sync.RWMutex
	outArgsForCall []struct {
		arg1 io.Reader
		arg2 turbine.Output
	}
	outReturns struct {
		result1 turbine.Output
		result2 error
	}
	CheckStub        func(turbine.Input) ([]turbine.Version, error)
	checkMutex       sync.RWMutex
	checkArgsForCall []struct {
		arg1 turbine.Input
	}
	checkReturns struct {
		result1 []turbine.Version
		result2 error
	}
}

func (fake *FakeResource) In(arg1 turbine.Input) (io.Reader, turbine.Input, turbine.Config, error) {
	fake.inMutex.Lock()
	fake.inArgsForCall = append(fake.inArgsForCall, struct {
		arg1 turbine.Input
	}{arg1})
	fake.inMutex.Unlock()
	if fake.InStub != nil {
		return fake.InStub(arg1)
	} else {
		return fake.inReturns.result1, fake.inReturns.result2, fake.inReturns.result3, fake.inReturns.result4
	}
}

func (fake *FakeResource) InCallCount() int {
	fake.inMutex.RLock()
	defer fake.inMutex.RUnlock()
	return len(fake.inArgsForCall)
}

func (fake *FakeResource) InArgsForCall(i int) turbine.Input {
	fake.inMutex.RLock()
	defer fake.inMutex.RUnlock()
	return fake.inArgsForCall[i].arg1
}

func (fake *FakeResource) InReturns(result1 io.Reader, result2 turbine.Input, result3 turbine.Config, result4 error) {
	fake.InStub = nil
	fake.inReturns = struct {
		result1 io.Reader
		result2 turbine.Input
		result3 turbine.Config
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeResource) Out(arg1 io.Reader, arg2 turbine.Output) (turbine.Output, error) {
	fake.outMutex.Lock()
	fake.outArgsForCall = append(fake.outArgsForCall, struct {
		arg1 io.Reader
		arg2 turbine.Output
	}{arg1, arg2})
	fake.outMutex.Unlock()
	if fake.OutStub != nil {
		return fake.OutStub(arg1, arg2)
	} else {
		return fake.outReturns.result1, fake.outReturns.result2
	}
}

func (fake *FakeResource) OutCallCount() int {
	fake.outMutex.RLock()
	defer fake.outMutex.RUnlock()
	return len(fake.outArgsForCall)
}

func (fake *FakeResource) OutArgsForCall(i int) (io.Reader, turbine.Output) {
	fake.outMutex.RLock()
	defer fake.outMutex.RUnlock()
	return fake.outArgsForCall[i].arg1, fake.outArgsForCall[i].arg2
}

func (fake *FakeResource) OutReturns(result1 turbine.Output, result2 error) {
	fake.OutStub = nil
	fake.outReturns = struct {
		result1 turbine.Output
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) Check(arg1 turbine.Input) ([]turbine.Version, error) {
	fake.checkMutex.Lock()
	fake.checkArgsForCall = append(fake.checkArgsForCall, struct {
		arg1 turbine.Input
	}{arg1})
	fake.checkMutex.Unlock()
	if fake.CheckStub != nil {
		return fake.CheckStub(arg1)
	} else {
		return fake.checkReturns.result1, fake.checkReturns.result2
	}
}

func (fake *FakeResource) CheckCallCount() int {
	fake.checkMutex.RLock()
	defer fake.checkMutex.RUnlock()
	return len(fake.checkArgsForCall)
}

func (fake *FakeResource) CheckArgsForCall(i int) turbine.Input {
	fake.checkMutex.RLock()
	defer fake.checkMutex.RUnlock()
	return fake.checkArgsForCall[i].arg1
}

func (fake *FakeResource) CheckReturns(result1 []turbine.Version, result2 error) {
	fake.CheckStub = nil
	fake.checkReturns = struct {
		result1 []turbine.Version
		result2 error
	}{result1, result2}
}

var _ resource.Resource = new(FakeResource)
