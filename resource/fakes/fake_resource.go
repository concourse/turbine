// This file was generated by counterfeiter
package fakes

import (
	"io"
	"sync"

	"github.com/winston-ci/prole/api/builds"
	. "github.com/winston-ci/prole/resource"
)

type FakeResource struct {
	InStub        func(builds.Input) (io.Reader, builds.Input, builds.Config, error)
	inMutex       sync.RWMutex
	inArgsForCall []struct {
		arg1 builds.Input
	}
	inReturns struct {
		result1 io.Reader
		result2 builds.Input
		result3 builds.Config
		result4 error
	}
	OutStub        func(io.Reader, builds.Output) (builds.Output, error)
	outMutex       sync.RWMutex
	outArgsForCall []struct {
		arg1 io.Reader
		arg2 builds.Output
	}
	outReturns struct {
		result1 builds.Output
		result2 error
	}
	CheckStub        func(builds.Input) ([]builds.Version, error)
	checkMutex       sync.RWMutex
	checkArgsForCall []struct {
		arg1 builds.Input
	}
	checkReturns struct {
		result1 []builds.Version
		result2 error
	}
}

func (fake *FakeResource) In(arg1 builds.Input) (io.Reader, builds.Input, builds.Config, error) {
	fake.inMutex.Lock()
	defer fake.inMutex.Unlock()
	fake.inArgsForCall = append(fake.inArgsForCall, struct {
		arg1 builds.Input
	}{arg1})
	if fake.InStub != nil {
		return fake.InStub(arg1)
	} else {
		return fake.inReturns.result1, fake.inReturns.result2, fake.inReturns.result3, fake.inReturns.result4
	}
}

func (fake *FakeResource) InCallCount() int {
	fake.inMutex.RLock()
	defer fake.inMutex.RUnlock()
	return len(fake.inArgsForCall)
}

func (fake *FakeResource) InArgsForCall(i int) builds.Input {
	fake.inMutex.RLock()
	defer fake.inMutex.RUnlock()
	return fake.inArgsForCall[i].arg1
}

func (fake *FakeResource) InReturns(result1 io.Reader, result2 builds.Input, result3 builds.Config, result4 error) {
	fake.inReturns = struct {
		result1 io.Reader
		result2 builds.Input
		result3 builds.Config
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeResource) Out(arg1 io.Reader, arg2 builds.Output) (builds.Output, error) {
	fake.outMutex.Lock()
	defer fake.outMutex.Unlock()
	fake.outArgsForCall = append(fake.outArgsForCall, struct {
		arg1 io.Reader
		arg2 builds.Output
	}{arg1, arg2})
	if fake.OutStub != nil {
		return fake.OutStub(arg1, arg2)
	} else {
		return fake.outReturns.result1, fake.outReturns.result2
	}
}

func (fake *FakeResource) OutCallCount() int {
	fake.outMutex.RLock()
	defer fake.outMutex.RUnlock()
	return len(fake.outArgsForCall)
}

func (fake *FakeResource) OutArgsForCall(i int) (io.Reader, builds.Output) {
	fake.outMutex.RLock()
	defer fake.outMutex.RUnlock()
	return fake.outArgsForCall[i].arg1, fake.outArgsForCall[i].arg2
}

func (fake *FakeResource) OutReturns(result1 builds.Output, result2 error) {
	fake.outReturns = struct {
		result1 builds.Output
		result2 error
	}{result1, result2}
}

func (fake *FakeResource) Check(arg1 builds.Input) ([]builds.Version, error) {
	fake.checkMutex.Lock()
	defer fake.checkMutex.Unlock()
	fake.checkArgsForCall = append(fake.checkArgsForCall, struct {
		arg1 builds.Input
	}{arg1})
	if fake.CheckStub != nil {
		return fake.CheckStub(arg1)
	} else {
		return fake.checkReturns.result1, fake.checkReturns.result2
	}
}

func (fake *FakeResource) CheckCallCount() int {
	fake.checkMutex.RLock()
	defer fake.checkMutex.RUnlock()
	return len(fake.checkArgsForCall)
}

func (fake *FakeResource) CheckArgsForCall(i int) builds.Input {
	fake.checkMutex.RLock()
	defer fake.checkMutex.RUnlock()
	return fake.checkArgsForCall[i].arg1
}

func (fake *FakeResource) CheckReturns(result1 []builds.Version, result2 error) {
	fake.checkReturns = struct {
		result1 []builds.Version
		result2 error
	}{result1, result2}
}

var _ Resource = new(FakeResource)
