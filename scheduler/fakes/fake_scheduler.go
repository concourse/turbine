// This file was generated by counterfeiter
package fakes

import (
	"sync"

	gapi "github.com/cloudfoundry-incubator/garden/api"
	"github.com/concourse/turbine/api/builds"
	"github.com/concourse/turbine/event"
	"github.com/concourse/turbine/scheduler"
)

type FakeScheduler struct {
	StartStub        func(builds.Build)
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 builds.Build
	}
	RestoreStub        func(scheduler.ScheduledBuild)
	restoreMutex       sync.RWMutex
	restoreArgsForCall []struct {
		arg1 scheduler.ScheduledBuild
	}
	AbortStub        func(guid string)
	abortMutex       sync.RWMutex
	abortArgsForCall []struct {
		guid string
	}
	HijackStub        func(guid string, process gapi.ProcessSpec, io gapi.ProcessIO) (gapi.Process, error)
	hijackMutex       sync.RWMutex
	hijackArgsForCall []struct {
		guid    string
		process gapi.ProcessSpec
		io      gapi.ProcessIO
	}
	hijackReturns struct {
		result1 gapi.Process
		result2 error
	}
	SubscribeStub        func(guid string, from uint) (<-chan event.Event, chan<- struct{}, error)
	subscribeMutex       sync.RWMutex
	subscribeArgsForCall []struct {
		guid string
		from uint
	}
	subscribeReturns struct {
		result1 <-chan event.Event
		result2 chan<- struct{}
		result3 error
	}
	DrainStub        func() []scheduler.ScheduledBuild
	drainMutex       sync.RWMutex
	drainArgsForCall []struct{}
	drainReturns struct {
		result1 []scheduler.ScheduledBuild
	}
}

func (fake *FakeScheduler) Start(arg1 builds.Build) {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 builds.Build
	}{arg1})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		fake.StartStub(arg1)
	}
}

func (fake *FakeScheduler) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeScheduler) StartArgsForCall(i int) builds.Build {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return fake.startArgsForCall[i].arg1
}

func (fake *FakeScheduler) Restore(arg1 scheduler.ScheduledBuild) {
	fake.restoreMutex.Lock()
	fake.restoreArgsForCall = append(fake.restoreArgsForCall, struct {
		arg1 scheduler.ScheduledBuild
	}{arg1})
	fake.restoreMutex.Unlock()
	if fake.RestoreStub != nil {
		fake.RestoreStub(arg1)
	}
}

func (fake *FakeScheduler) RestoreCallCount() int {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	return len(fake.restoreArgsForCall)
}

func (fake *FakeScheduler) RestoreArgsForCall(i int) scheduler.ScheduledBuild {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	return fake.restoreArgsForCall[i].arg1
}

func (fake *FakeScheduler) Abort(guid string) {
	fake.abortMutex.Lock()
	fake.abortArgsForCall = append(fake.abortArgsForCall, struct {
		guid string
	}{guid})
	fake.abortMutex.Unlock()
	if fake.AbortStub != nil {
		fake.AbortStub(guid)
	}
}

func (fake *FakeScheduler) AbortCallCount() int {
	fake.abortMutex.RLock()
	defer fake.abortMutex.RUnlock()
	return len(fake.abortArgsForCall)
}

func (fake *FakeScheduler) AbortArgsForCall(i int) string {
	fake.abortMutex.RLock()
	defer fake.abortMutex.RUnlock()
	return fake.abortArgsForCall[i].guid
}

func (fake *FakeScheduler) Hijack(guid string, process gapi.ProcessSpec, io gapi.ProcessIO) (gapi.Process, error) {
	fake.hijackMutex.Lock()
	fake.hijackArgsForCall = append(fake.hijackArgsForCall, struct {
		guid    string
		process gapi.ProcessSpec
		io      gapi.ProcessIO
	}{guid, process, io})
	fake.hijackMutex.Unlock()
	if fake.HijackStub != nil {
		return fake.HijackStub(guid, process, io)
	} else {
		return fake.hijackReturns.result1, fake.hijackReturns.result2
	}
}

func (fake *FakeScheduler) HijackCallCount() int {
	fake.hijackMutex.RLock()
	defer fake.hijackMutex.RUnlock()
	return len(fake.hijackArgsForCall)
}

func (fake *FakeScheduler) HijackArgsForCall(i int) (string, gapi.ProcessSpec, gapi.ProcessIO) {
	fake.hijackMutex.RLock()
	defer fake.hijackMutex.RUnlock()
	return fake.hijackArgsForCall[i].guid, fake.hijackArgsForCall[i].process, fake.hijackArgsForCall[i].io
}

func (fake *FakeScheduler) HijackReturns(result1 gapi.Process, result2 error) {
	fake.HijackStub = nil
	fake.hijackReturns = struct {
		result1 gapi.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeScheduler) Subscribe(guid string, from uint) (<-chan event.Event, chan<- struct{}, error) {
	fake.subscribeMutex.Lock()
	fake.subscribeArgsForCall = append(fake.subscribeArgsForCall, struct {
		guid string
		from uint
	}{guid, from})
	fake.subscribeMutex.Unlock()
	if fake.SubscribeStub != nil {
		return fake.SubscribeStub(guid, from)
	} else {
		return fake.subscribeReturns.result1, fake.subscribeReturns.result2, fake.subscribeReturns.result3
	}
}

func (fake *FakeScheduler) SubscribeCallCount() int {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	return len(fake.subscribeArgsForCall)
}

func (fake *FakeScheduler) SubscribeArgsForCall(i int) (string, uint) {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	return fake.subscribeArgsForCall[i].guid, fake.subscribeArgsForCall[i].from
}

func (fake *FakeScheduler) SubscribeReturns(result1 <-chan event.Event, result2 chan<- struct{}, result3 error) {
	fake.SubscribeStub = nil
	fake.subscribeReturns = struct {
		result1 <-chan event.Event
		result2 chan<- struct{}
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeScheduler) Drain() []scheduler.ScheduledBuild {
	fake.drainMutex.Lock()
	fake.drainArgsForCall = append(fake.drainArgsForCall, struct{}{})
	fake.drainMutex.Unlock()
	if fake.DrainStub != nil {
		return fake.DrainStub()
	} else {
		return fake.drainReturns.result1
	}
}

func (fake *FakeScheduler) DrainCallCount() int {
	fake.drainMutex.RLock()
	defer fake.drainMutex.RUnlock()
	return len(fake.drainArgsForCall)
}

func (fake *FakeScheduler) DrainReturns(result1 []scheduler.ScheduledBuild) {
	fake.DrainStub = nil
	fake.drainReturns = struct {
		result1 []scheduler.ScheduledBuild
	}{result1}
}

var _ scheduler.Scheduler = new(FakeScheduler)
